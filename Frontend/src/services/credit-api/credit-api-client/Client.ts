//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import * as Types from '../credit-api-client.types';
import type { AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import { throwException, isAxiosError } from '../credit-api-client.types';
import { getAxios, getBaseUrl } from './helpers';

/**
 * Issue a new loan to a client
 * @param body (optional) 
 * @return Loan issued and funds credited to the acount
 */
export function creditsPOST(body?: Types.IssueCreditRequest | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.CreditResponse> {
    let url_ = getBaseUrl() + "/credits";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = Types.serializeIssueCreditRequest(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigCreditsPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigCreditsPOST?.headers,
            "Content-Type": "application/json",
            "Accept": "application/json",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processCreditsPOST(_response);
    });
}

function processCreditsPOST(response: AxiosResponse): Promise<Types.CreditResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 201) {
        const _responseText = response.data;
        let result201: any = null;
        let resultData201  = _responseText;
        result201 = Types.initCreditResponse(resultData201);
        return Promise.resolve<Types.CreditResponse>(result201);

    } else if (status === 400) {
        const _responseText = response.data;
        let result400: any = null;
        let resultData400  = _responseText;
        result400 = Types.initProblemDetails(resultData400);
        return throwException("Validation error or account not found in CoreService", status, _responseText, _headers, result400);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.CreditResponse>(null as any);
}

/**
 * List credits for a client
 * @param clientId (optional) Client whose credits to return
 * @return List of credits returned
 */
export function creditsAll(clientId?: number | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.CreditResponse[]> {
    let url_ = getBaseUrl() + "/credits?";
    if (clientId === null)
        throw new Error("The parameter 'clientId' cannot be null.");
    else if (clientId !== undefined)
        url_ += "clientId=" + encodeURIComponent("" + clientId) + "&";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigCreditsAll,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigCreditsAll?.headers,
            "Accept": "application/json",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processCreditsAll(_response);
    });
}

function processCreditsAll(response: AxiosResponse): Promise<Types.CreditResponse[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
              result200 = resultData200.map(item => 
                Types.initCreditResponse(item)
              );
            }
        return Promise.resolve<Types.CreditResponse[]>(result200);

    } else if (status === 400) {
        const _responseText = response.data;
        let result400: any = null;
        let resultData400  = _responseText;
        result400 = Types.initProblemDetails(resultData400);
        return throwException("clientId is missing", status, _responseText, _headers, result400);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.CreditResponse[]>(null as any);
}

/**
 * Get full credit details including repayment schedule
 * @param id Credit ID
 * @return Credit details returned
 */
export function creditsGET(id: number, config?: AxiosRequestConfig | undefined): Promise<Types.CreditDetailResponse> {
    let url_ = getBaseUrl() + "/credits/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigCreditsGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigCreditsGET?.headers,
            "Accept": "application/json",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processCreditsGET(_response);
    });
}

function processCreditsGET(response: AxiosResponse): Promise<Types.CreditDetailResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.initCreditDetailResponse(resultData200);
        return Promise.resolve<Types.CreditDetailResponse>(result200);

    } else if (status === 403) {
        const _responseText = response.data;
        let result403: any = null;
        let resultData403  = _responseText;
        result403 = Types.initProblemDetails(resultData403);
        return throwException("Client is not the owner of this credit", status, _responseText, _headers, result403);

    } else if (status === 404) {
        const _responseText = response.data;
        let result404: any = null;
        let resultData404  = _responseText;
        result404 = Types.initProblemDetails(resultData404);
        return throwException("Credit not found", status, _responseText, _headers, result404);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.CreditDetailResponse>(null as any);
}

/**
 * Fully repay a credit early
 * @param id Credit ID to repay
 * @return Credit fully repaid and closed
 */
export function repay(id: number, config?: AxiosRequestConfig | undefined): Promise<Types.CreditResponse> {
    let url_ = getBaseUrl() + "/credits/{id}/repay";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigRepay,
        ...config,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigRepay?.headers,
            "Accept": "application/json",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processRepay(_response);
    });
}

function processRepay(response: AxiosResponse): Promise<Types.CreditResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.initCreditResponse(resultData200);
        return Promise.resolve<Types.CreditResponse>(result200);

    } else if (status === 400) {
        const _responseText = response.data;
        let result400: any = null;
        let resultData400  = _responseText;
        result400 = Types.initProblemDetails(resultData400);
        return throwException("Insufficient funds or credit is already closed", status, _responseText, _headers, result400);

    } else if (status === 403) {
        const _responseText = response.data;
        let result403: any = null;
        let resultData403  = _responseText;
        result403 = Types.initProblemDetails(resultData403);
        return throwException("Client is not the owner of this credit", status, _responseText, _headers, result403);

    } else if (status === 404) {
        const _responseText = response.data;
        let result404: any = null;
        let resultData404  = _responseText;
        result404 = Types.initProblemDetails(resultData404);
        return throwException("Credit not found", status, _responseText, _headers, result404);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.CreditResponse>(null as any);
}

/**
 * Get all available credit tariffs
 * @return List of tariffs returned
 */
export function tariffsAll(config?: AxiosRequestConfig | undefined): Promise<Types.TariffResponse[]> {
    let url_ = getBaseUrl() + "/tariffs";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigTariffsAll,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigTariffsAll?.headers,
            "Accept": "application/json",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processTariffsAll(_response);
    });
}

function processTariffsAll(response: AxiosResponse): Promise<Types.TariffResponse[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
              result200 = resultData200.map(item => 
                Types.initTariffResponse(item)
              );
            }
        return Promise.resolve<Types.TariffResponse[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.TariffResponse[]>(null as any);
}

/**
 * Create a new credit tariff
 * @param body (optional) 
 * @return Tariff created successfully
 */
export function tariffs(body?: Types.CreateTariffRequest | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.TariffResponse> {
    let url_ = getBaseUrl() + "/tariffs";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = Types.serializeCreateTariffRequest(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigTariffs,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigTariffs?.headers,
            "Content-Type": "application/json",
            "Accept": "application/json",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processTariffs(_response);
    });
}

function processTariffs(response: AxiosResponse): Promise<Types.TariffResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 201) {
        const _responseText = response.data;
        let result201: any = null;
        let resultData201  = _responseText;
        result201 = Types.initTariffResponse(resultData201);
        return Promise.resolve<Types.TariffResponse>(result201);

    } else if (status === 400) {
        const _responseText = response.data;
        let result400: any = null;
        let resultData400  = _responseText;
        result400 = Types.initProblemDetails(resultData400);
        return throwException("Validation error", status, _responseText, _headers, result400);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.TariffResponse>(null as any);
}
let _requestConfigCreditsPOST: Partial<AxiosRequestConfig> | null;
export function getCreditsPOSTRequestConfig() {
  return _requestConfigCreditsPOST;
}
export function setCreditsPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigCreditsPOST = value;
}
export function patchCreditsPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigCreditsPOST = patch(_requestConfigCreditsPOST ?? {});
}

let _requestConfigCreditsAll: Partial<AxiosRequestConfig> | null;
export function getCreditsAllRequestConfig() {
  return _requestConfigCreditsAll;
}
export function setCreditsAllRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigCreditsAll = value;
}
export function patchCreditsAllRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigCreditsAll = patch(_requestConfigCreditsAll ?? {});
}

let _requestConfigCreditsGET: Partial<AxiosRequestConfig> | null;
export function getCreditsGETRequestConfig() {
  return _requestConfigCreditsGET;
}
export function setCreditsGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigCreditsGET = value;
}
export function patchCreditsGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigCreditsGET = patch(_requestConfigCreditsGET ?? {});
}

let _requestConfigRepay: Partial<AxiosRequestConfig> | null;
export function getRepayRequestConfig() {
  return _requestConfigRepay;
}
export function setRepayRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigRepay = value;
}
export function patchRepayRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigRepay = patch(_requestConfigRepay ?? {});
}

let _requestConfigTariffsAll: Partial<AxiosRequestConfig> | null;
export function getTariffsAllRequestConfig() {
  return _requestConfigTariffsAll;
}
export function setTariffsAllRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigTariffsAll = value;
}
export function patchTariffsAllRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigTariffsAll = patch(_requestConfigTariffsAll ?? {});
}

let _requestConfigTariffs: Partial<AxiosRequestConfig> | null;
export function getTariffsRequestConfig() {
  return _requestConfigTariffs;
}
export function setTariffsRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigTariffs = value;
}
export function patchTariffsRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigTariffs = patch(_requestConfigTariffs ?? {});
}