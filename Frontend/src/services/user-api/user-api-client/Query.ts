//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import * as Types from '../user-api-client.types';
import { useQuery, useMutation } from '@tanstack/react-query';
import type { UseQueryResult, QueryFunctionContext, UseQueryOptions, QueryClient, QueryKey, MutationKey, UseMutationOptions, UseMutationResult, QueryMeta, MutationMeta } from '@tanstack/react-query';
import { trimArrayEnd, isParameterObject, getBaseUrl, addMetaToOptions } from './helpers';
import type { QueryMetaContextValue } from 'react-query-swagger';
import { QueryMetaContext } from 'react-query-swagger';
import { useContext } from 'react';
import * as Client from './Client'
export { Client };
import type { AxiosRequestConfig } from 'axios';


export type UsersGETQueryParameters = {
  id: number ;
}

export type BlockQueryParameters = {
  id: number ;
}

export type UnblockQueryParameters = {
  id: number ;
}

export function loginUrl(): string {
  let url_ = getBaseUrl() + "/auth/login";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function loginMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'login',
    ]);
}

/**
 * Issue a JWT token for valid credentials
 * @param body (optional) 
 * @return Token issued successfully
 */
export function useLoginMutation<TContext>(options?: Omit<UseMutationOptions<Types.LoginResponse, unknown, Types.LoginRequest, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.LoginResponse, unknown, Types.LoginRequest, TContext> {
  const key = loginMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.LoginRequest) => Client.login(body),
    mutationKey: key,
  });
}
  
export function publicKeyUrl(): string {
  let url_ = getBaseUrl() + "/auth/public-key";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let publicKeyDefaultOptions: Omit<UseQueryOptions<Types.PublicKeyResponse, unknown, Types.PublicKeyResponse>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PublicKeyResponse, unknown, Types.PublicKeyResponse>, 'queryFn'>> = {
};
export function getPublicKeyDefaultOptions() {
  return publicKeyDefaultOptions;
};
export function setPublicKeyDefaultOptions(options: typeof publicKeyDefaultOptions) {
  publicKeyDefaultOptions = options;
}

export function publicKeyQueryKey(): QueryKey;
export function publicKeyQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'publicKey',
    ]);
}
export function __publicKey(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.publicKey(
axiosConfig    );
}

/**
 * Get the RSA public key used to validate issued JWTs
 * @return Public key returned
 */
export function usePublicKeyQuery<TSelectData = Types.PublicKeyResponse, TError = unknown>(options?: Omit<UseQueryOptions<Types.PublicKeyResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function usePublicKeyQuery<TSelectData = Types.PublicKeyResponse, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PublicKeyResponse, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PublicKeyResponse, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __publicKey(context, axiosConfig) : __publicKey,
    queryKey: publicKeyQueryKey(),
    ...publicKeyDefaultOptions as unknown as Omit<UseQueryOptions<Types.PublicKeyResponse, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get the RSA public key used to validate issued JWTs
 * @return Public key returned
 */
export function setPublicKeyData(queryClient: QueryClient, updater: (data: Types.PublicKeyResponse | undefined) => Types.PublicKeyResponse, ) {
  queryClient.setQueryData(publicKeyQueryKey(),
    updater
  );
}

/**
 * Get the RSA public key used to validate issued JWTs
 * @return Public key returned
 */
export function setPublicKeyDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PublicKeyResponse | undefined) => Types.PublicKeyResponse) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function usersAllUrl(): string {
  let url_ = getBaseUrl() + "/users";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let usersAllDefaultOptions: Omit<UseQueryOptions<Types.UserResponse[], unknown, Types.UserResponse[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.UserResponse[], unknown, Types.UserResponse[]>, 'queryFn'>> = {
};
export function getUsersAllDefaultOptions() {
  return usersAllDefaultOptions;
};
export function setUsersAllDefaultOptions(options: typeof usersAllDefaultOptions) {
  usersAllDefaultOptions = options;
}

export function usersAllQueryKey(): QueryKey;
export function usersAllQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'usersAll',
    ]);
}
export function __usersAll(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.usersAll(
axiosConfig    );
}

/**
 * Get a list of all users (clients and employees)
 * @return List of users returned
 */
export function useUsersAllQuery<TSelectData = Types.UserResponse[], TError = unknown>(options?: Omit<UseQueryOptions<Types.UserResponse[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useUsersAllQuery<TSelectData = Types.UserResponse[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.UserResponse[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.UserResponse[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __usersAll(context, axiosConfig) : __usersAll,
    queryKey: usersAllQueryKey(),
    ...usersAllDefaultOptions as unknown as Omit<UseQueryOptions<Types.UserResponse[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get a list of all users (clients and employees)
 * @return List of users returned
 */
export function setUsersAllData(queryClient: QueryClient, updater: (data: Types.UserResponse[] | undefined) => Types.UserResponse[], ) {
  queryClient.setQueryData(usersAllQueryKey(),
    updater
  );
}

/**
 * Get a list of all users (clients and employees)
 * @return List of users returned
 */
export function setUsersAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.UserResponse[] | undefined) => Types.UserResponse[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function usersPOSTUrl(): string {
  let url_ = getBaseUrl() + "/users";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function usersPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'usersPOST',
    ]);
}

/**
 * Create a new client or employee
 * @param body (optional) 
 * @return User created successfully
 */
export function useUsersPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.UserResponse, unknown, Types.CreateUserRequest, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.UserResponse, unknown, Types.CreateUserRequest, TContext> {
  const key = usersPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.CreateUserRequest) => Client.usersPOST(body),
    mutationKey: key,
  });
}
  
export function usersGETUrl(id: number): string {
  let url_ = getBaseUrl() + "/users/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let usersGETDefaultOptions: Omit<UseQueryOptions<Types.UserResponse, unknown, Types.UserResponse>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.UserResponse, unknown, Types.UserResponse>, 'queryFn'>> = {
};
export function getUsersGETDefaultOptions() {
  return usersGETDefaultOptions;
};
export function setUsersGETDefaultOptions(options: typeof usersGETDefaultOptions) {
  usersGETDefaultOptions = options;
}

export function usersGETQueryKey(id: number): QueryKey;
export function usersGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as UsersGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'usersGET',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'usersGET',
        ...params
      ]);
  }
}
export function __usersGET(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.usersGET(
      context.queryKey[2] as number,axiosConfig    );
}

export function useUsersGETQuery<TSelectData = Types.UserResponse, TError = unknown>(dto: UsersGETQueryParameters, options?: Omit<UseQueryOptions<Types.UserResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get a user profile by ID
 * @param id User ID
 * @return User profile returned
 */
export function useUsersGETQuery<TSelectData = Types.UserResponse, TError = unknown>(id: number, options?: Omit<UseQueryOptions<Types.UserResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useUsersGETQuery<TSelectData = Types.UserResponse, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.UserResponse, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as UsersGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.UserResponse, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __usersGET(context, axiosConfig) : __usersGET,
    queryKey: usersGETQueryKey(id),
    ...usersGETDefaultOptions as unknown as Omit<UseQueryOptions<Types.UserResponse, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get a user profile by ID
 * @param id User ID
 * @return User profile returned
 */
export function setUsersGETData(queryClient: QueryClient, updater: (data: Types.UserResponse | undefined) => Types.UserResponse, id: number) {
  queryClient.setQueryData(usersGETQueryKey(id),
    updater
  );
}

/**
 * Get a user profile by ID
 * @param id User ID
 * @return User profile returned
 */
export function setUsersGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.UserResponse | undefined) => Types.UserResponse) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function blockUrl(id: number): string {
  let url_ = getBaseUrl() + "/users/{id}/block";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function blockMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'block',
      id as any,
    ]);
}

/**
 * Block a user
 * @param id User ID
 * @return User blocked successfully
 */
export function useBlockMutation<TContext>(id: number, options?: Omit<UseMutationOptions<void, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, void, TContext> {
  const key = blockMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.block(id),
    mutationKey: key,
  });
}
  
type Block__MutationParameters = BlockQueryParameters

/**
 * Block a user
 * @param id User ID
 * @return User blocked successfully
 */
export function useBlockMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, Block__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: BlockQueryParameters}): UseMutationResult<void, unknown, Block__MutationParameters, TContext> {
  const key = blockMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: Block__MutationParameters) => Client.block(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function unblockUrl(id: number): string {
  let url_ = getBaseUrl() + "/users/{id}/unblock";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function unblockMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'unblock',
      id as any,
    ]);
}

/**
 * Unblock a user
 * @param id User ID
 * @return User unblocked successfully
 */
export function useUnblockMutation<TContext>(id: number, options?: Omit<UseMutationOptions<void, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, void, TContext> {
  const key = unblockMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.unblock(id),
    mutationKey: key,
  });
}
  
type Unblock__MutationParameters = UnblockQueryParameters

/**
 * Unblock a user
 * @param id User ID
 * @return User unblocked successfully
 */
export function useUnblockMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, Unblock__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: UnblockQueryParameters}): UseMutationResult<void, unknown, Unblock__MutationParameters, TContext> {
  const key = unblockMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: Unblock__MutationParameters) => Client.unblock(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}