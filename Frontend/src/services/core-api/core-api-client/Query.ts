//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import * as Types from '../core-api-client.types';
import { useQuery, useMutation } from '@tanstack/react-query';
import type { UseQueryResult, QueryFunctionContext, UseQueryOptions, QueryClient, QueryKey, MutationKey, UseMutationOptions, UseMutationResult, QueryMeta, MutationMeta } from '@tanstack/react-query';
import { trimArrayEnd, isParameterObject, getBaseUrl, addMetaToOptions } from './helpers';
import type { QueryMetaContextValue } from 'react-query-swagger';
import { QueryMetaContext } from 'react-query-swagger';
import { useContext } from 'react';
import * as Client from './Client'
export { Client };
import type { AxiosRequestConfig } from 'axios';

export type AccountsAllQueryParameters = {
  ownerId?: number | undefined ;
}

export type AccountsGETQueryParameters = {
  id: number ;
}

export type AccountsDELETEQueryParameters = {
  id: number ;
}

export type DepositQueryParameters = {
  id: number ;
}

export type WithdrawQueryParameters = {
  id: number ;
}

export type TransferQueryParameters = {
  id: number ;
}

export type DebitQueryParameters = {
  id: number ;
}

export type TransactionsQueryParameters = {
  id: number ;
  page?: number | undefined ;
  pageSize?: number | undefined ;
}

export function accountsPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/accounts";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function accountsPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'accountsPOST',
    ]);
}

/**
 * @return Created
 */
export function useAccountsPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.AccountResponse, unknown, Types.CreateAccountCommand, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AccountResponse, unknown, Types.CreateAccountCommand, TContext> {
  const key = accountsPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.CreateAccountCommand) => Client.accountsPOST(body),
    mutationKey: key,
  });
}
  
export function accountsAllUrl(ownerId?: number | undefined): string {
  let url_ = getBaseUrl() + "/api/accounts?";
if (ownerId === null)
    throw new Error("The parameter 'ownerId' cannot be null.");
else if (ownerId !== undefined)
    url_ += "ownerId=" + encodeURIComponent("" + ownerId) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let accountsAllDefaultOptions: Omit<UseQueryOptions<Types.AccountResponse[], unknown, Types.AccountResponse[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.AccountResponse[], unknown, Types.AccountResponse[]>, 'queryFn'>> = {
};
export function getAccountsAllDefaultOptions() {
  return accountsAllDefaultOptions;
};
export function setAccountsAllDefaultOptions(options: typeof accountsAllDefaultOptions) {
  accountsAllDefaultOptions = options;
}

export function accountsAllQueryKey(ownerId?: number | undefined): QueryKey;
export function accountsAllQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { ownerId,  } = params[0] as AccountsAllQueryParameters;

    return trimArrayEnd([
        'Client',
        'accountsAll',
        ownerId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'accountsAll',
        ...params
      ]);
  }
}
export function __accountsAll(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.accountsAll(
      context.queryKey[2] as number | undefined,axiosConfig    );
}

export function useAccountsAllQuery<TSelectData = Types.AccountResponse[], TError = unknown>(dto: AccountsAllQueryParameters, options?: Omit<UseQueryOptions<Types.AccountResponse[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @param ownerId (optional) 
 * @return OK
 */
export function useAccountsAllQuery<TSelectData = Types.AccountResponse[], TError = unknown>(ownerId?: number | undefined, options?: Omit<UseQueryOptions<Types.AccountResponse[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useAccountsAllQuery<TSelectData = Types.AccountResponse[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.AccountResponse[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let ownerId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ ownerId,  } = params[0] as AccountsAllQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [ownerId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.AccountResponse[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __accountsAll(context, axiosConfig) : __accountsAll,
    queryKey: accountsAllQueryKey(ownerId),
    ...accountsAllDefaultOptions as unknown as Omit<UseQueryOptions<Types.AccountResponse[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @param ownerId (optional) 
 * @return OK
 */
export function setAccountsAllData(queryClient: QueryClient, updater: (data: Types.AccountResponse[] | undefined) => Types.AccountResponse[], ownerId?: number | undefined) {
  queryClient.setQueryData(accountsAllQueryKey(ownerId),
    updater
  );
}

/**
 * @param ownerId (optional) 
 * @return OK
 */
export function setAccountsAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.AccountResponse[] | undefined) => Types.AccountResponse[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function accountsGETUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/accounts/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let accountsGETDefaultOptions: Omit<UseQueryOptions<Types.AccountResponse, unknown, Types.AccountResponse>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.AccountResponse, unknown, Types.AccountResponse>, 'queryFn'>> = {
};
export function getAccountsGETDefaultOptions() {
  return accountsGETDefaultOptions;
};
export function setAccountsGETDefaultOptions(options: typeof accountsGETDefaultOptions) {
  accountsGETDefaultOptions = options;
}

export function accountsGETQueryKey(id: number): QueryKey;
export function accountsGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as AccountsGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'accountsGET',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'accountsGET',
        ...params
      ]);
  }
}
export function __accountsGET(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.accountsGET(
      context.queryKey[2] as number,axiosConfig    );
}

export function useAccountsGETQuery<TSelectData = Types.AccountResponse, TError = unknown>(dto: AccountsGETQueryParameters, options?: Omit<UseQueryOptions<Types.AccountResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return OK
 */
export function useAccountsGETQuery<TSelectData = Types.AccountResponse, TError = unknown>(id: number, options?: Omit<UseQueryOptions<Types.AccountResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useAccountsGETQuery<TSelectData = Types.AccountResponse, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.AccountResponse, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as AccountsGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.AccountResponse, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __accountsGET(context, axiosConfig) : __accountsGET,
    queryKey: accountsGETQueryKey(id),
    ...accountsGETDefaultOptions as unknown as Omit<UseQueryOptions<Types.AccountResponse, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setAccountsGETData(queryClient: QueryClient, updater: (data: Types.AccountResponse | undefined) => Types.AccountResponse, id: number) {
  queryClient.setQueryData(accountsGETQueryKey(id),
    updater
  );
}

/**
 * @return OK
 */
export function setAccountsGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.AccountResponse | undefined) => Types.AccountResponse) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function accountsDELETEUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/accounts/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function accountsDELETEMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'accountsDELETE',
      id as any,
    ]);
}

/**
 * @return OK
 */
export function useAccountsDELETEMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.AccountResponse, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AccountResponse, unknown, void, TContext> {
  const key = accountsDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.accountsDELETE(id),
    mutationKey: key,
  });
}
  
type AccountsDELETE__MutationParameters = AccountsDELETEQueryParameters

/**
 * @return OK
 */
export function useAccountsDELETEMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.AccountResponse, unknown, AccountsDELETE__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: AccountsDELETEQueryParameters}): UseMutationResult<Types.AccountResponse, unknown, AccountsDELETE__MutationParameters, TContext> {
  const key = accountsDELETEMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: AccountsDELETE__MutationParameters) => Client.accountsDELETE(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function depositUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/accounts/{id}/deposit";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function depositMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'deposit',
      id as any,
    ]);
}

/**
 * @return OK
 */
export function useDepositMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.TransactionResponse, unknown, Types.DepositRequest, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.TransactionResponse, unknown, Types.DepositRequest, TContext> {
  const key = depositMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.DepositRequest) => Client.deposit(id, body),
    mutationKey: key,
  });
}
  
type Deposit__MutationParameters = DepositQueryParameters & {
  body: Types.DepositRequest;
}

/**
 * @return OK
 */
export function useDepositMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.TransactionResponse, unknown, Deposit__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: DepositQueryParameters}): UseMutationResult<Types.TransactionResponse, unknown, Deposit__MutationParameters, TContext> {
  const key = depositMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: Deposit__MutationParameters) => Client.deposit(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function withdrawUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/accounts/{id}/withdraw";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function withdrawMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'withdraw',
      id as any,
    ]);
}

/**
 * @return OK
 */
export function useWithdrawMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.TransactionResponse, unknown, Types.WithdrawRequest, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.TransactionResponse, unknown, Types.WithdrawRequest, TContext> {
  const key = withdrawMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.WithdrawRequest) => Client.withdraw(id, body),
    mutationKey: key,
  });
}
  
type Withdraw__MutationParameters = WithdrawQueryParameters & {
  body: Types.WithdrawRequest;
}

/**
 * @return OK
 */
export function useWithdrawMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.TransactionResponse, unknown, Withdraw__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: WithdrawQueryParameters}): UseMutationResult<Types.TransactionResponse, unknown, Withdraw__MutationParameters, TContext> {
  const key = withdrawMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: Withdraw__MutationParameters) => Client.withdraw(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function transferUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/accounts/{id}/transfer";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function transferMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'transfer',
      id as any,
    ]);
}

/**
 * @return OK
 */
export function useTransferMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.TransactionResponse, unknown, Types.TransferRequest, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.TransactionResponse, unknown, Types.TransferRequest, TContext> {
  const key = transferMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.TransferRequest) => Client.transfer(id, body),
    mutationKey: key,
  });
}
  
type Transfer__MutationParameters = TransferQueryParameters & {
  body: Types.TransferRequest;
}

/**
 * @return OK
 */
export function useTransferMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.TransactionResponse, unknown, Transfer__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: TransferQueryParameters}): UseMutationResult<Types.TransactionResponse, unknown, Transfer__MutationParameters, TContext> {
  const key = transferMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: Transfer__MutationParameters) => Client.transfer(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function debitUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/accounts/{id}/debit";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function debitMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'debit',
      id as any,
    ]);
}

/**
 * @return OK
 */
export function useDebitMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.TransactionResponse, unknown, Types.DebitRequest, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.TransactionResponse, unknown, Types.DebitRequest, TContext> {
  const key = debitMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.DebitRequest) => Client.debit(id, body),
    mutationKey: key,
  });
}
  
type Debit__MutationParameters = DebitQueryParameters & {
  body: Types.DebitRequest;
}

/**
 * @return OK
 */
export function useDebitMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.TransactionResponse, unknown, Debit__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: DebitQueryParameters}): UseMutationResult<Types.TransactionResponse, unknown, Debit__MutationParameters, TContext> {
  const key = debitMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: Debit__MutationParameters) => Client.debit(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function transactionsUrl(id: number, page?: number | undefined, pageSize?: number | undefined): string {
  let url_ = getBaseUrl() + "/api/accounts/{id}/transactions?";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
if (page === null)
    throw new Error("The parameter 'page' cannot be null.");
else if (page !== undefined)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let transactionsDefaultOptions: Omit<UseQueryOptions<Types.PagedResponseOfTransactionResponse, unknown, Types.PagedResponseOfTransactionResponse>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PagedResponseOfTransactionResponse, unknown, Types.PagedResponseOfTransactionResponse>, 'queryFn'>> = {
};
export function getTransactionsDefaultOptions() {
  return transactionsDefaultOptions;
};
export function setTransactionsDefaultOptions(options: typeof transactionsDefaultOptions) {
  transactionsDefaultOptions = options;
}

export function transactionsQueryKey(dto: TransactionsQueryParameters): QueryKey;
export function transactionsQueryKey(id: number, page?: number | undefined, pageSize?: number | undefined): QueryKey;
export function transactionsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id, page, pageSize,  } = params[0] as TransactionsQueryParameters;

    return trimArrayEnd([
        'Client',
        'transactions',
        id as any,
        page as any,
        pageSize as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'transactions',
        ...params
      ]);
  }
}
export function __transactions(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.transactions(
      context.queryKey[2] as number,       context.queryKey[3] as number | undefined,       context.queryKey[4] as number | undefined,axiosConfig    );
}

export function useTransactionsQuery<TSelectData = Types.PagedResponseOfTransactionResponse, TError = unknown>(dto: TransactionsQueryParameters, options?: Omit<UseQueryOptions<Types.PagedResponseOfTransactionResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @param page (optional) 
 * @param pageSize (optional) 
 * @return OK
 */
export function useTransactionsQuery<TSelectData = Types.PagedResponseOfTransactionResponse, TError = unknown>(id: number, page?: number | undefined, pageSize?: number | undefined, options?: Omit<UseQueryOptions<Types.PagedResponseOfTransactionResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useTransactionsQuery<TSelectData = Types.PagedResponseOfTransactionResponse, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PagedResponseOfTransactionResponse, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  let page: any = undefined;
  let pageSize: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id, page, pageSize,  } = params[0] as TransactionsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, page, pageSize, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PagedResponseOfTransactionResponse, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __transactions(context, axiosConfig) : __transactions,
    queryKey: transactionsQueryKey(id, page, pageSize),
    ...transactionsDefaultOptions as unknown as Omit<UseQueryOptions<Types.PagedResponseOfTransactionResponse, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @param page (optional) 
 * @param pageSize (optional) 
 * @return OK
 */
export function setTransactionsData(queryClient: QueryClient, updater: (data: Types.PagedResponseOfTransactionResponse | undefined) => Types.PagedResponseOfTransactionResponse, id: number, page?: number | undefined, pageSize?: number | undefined) {
  queryClient.setQueryData(transactionsQueryKey(id, page, pageSize),
    updater
  );
}

/**
 * @param page (optional) 
 * @param pageSize (optional) 
 * @return OK
 */
export function setTransactionsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PagedResponseOfTransactionResponse | undefined) => Types.PagedResponseOfTransactionResponse) {
  queryClient.setQueryData(queryKey, updater);
}