//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import * as Types from '../core-api-client.types';
import type { AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import { throwException, isAxiosError } from '../core-api-client.types';
import { getAxios, getBaseUrl } from './helpers';

/**
 * @return Created
 */
export function accountsPOST(body: Types.CreateAccountCommand, config?: AxiosRequestConfig | undefined): Promise<Types.AccountResponse> {
    let url_ = getBaseUrl() + "/api/accounts";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = Types.serializeCreateAccountCommand(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigAccountsPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigAccountsPOST?.headers,
            "Content-Type": "application/json",
            "Accept": "application/json",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processAccountsPOST(_response);
    });
}

function processAccountsPOST(response: AxiosResponse): Promise<Types.AccountResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 201) {
        const _responseText = response.data;
        let result201: any = null;
        let resultData201  = _responseText;
        result201 = Types.initAccountResponse(resultData201);
        return Promise.resolve<Types.AccountResponse>(result201);

    } else if (status === 400) {
        const _responseText = response.data;
        let result400: any = null;
        let resultData400  = _responseText;
        result400 = Types.initProblemDetails(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.AccountResponse>(null as any);
}

/**
 * @param ownerId (optional) 
 * @return OK
 */
export function accountsAll(ownerId?: number | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.AccountResponse[]> {
    let url_ = getBaseUrl() + "/api/accounts?";
    if (ownerId === null)
        throw new Error("The parameter 'ownerId' cannot be null.");
    else if (ownerId !== undefined)
        url_ += "ownerId=" + encodeURIComponent("" + ownerId) + "&";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigAccountsAll,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigAccountsAll?.headers,
            "Accept": "application/json",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processAccountsAll(_response);
    });
}

function processAccountsAll(response: AxiosResponse): Promise<Types.AccountResponse[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
              result200 = resultData200.map(item => 
                Types.initAccountResponse(item)
              );
            }
        return Promise.resolve<Types.AccountResponse[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.AccountResponse[]>(null as any);
}

/**
 * @return OK
 */
export function accountsGET(id: number, config?: AxiosRequestConfig | undefined): Promise<Types.AccountResponse> {
    let url_ = getBaseUrl() + "/api/accounts/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigAccountsGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigAccountsGET?.headers,
            "Accept": "application/json",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processAccountsGET(_response);
    });
}

function processAccountsGET(response: AxiosResponse): Promise<Types.AccountResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.initAccountResponse(resultData200);
        return Promise.resolve<Types.AccountResponse>(result200);

    } else if (status === 403) {
        const _responseText = response.data;
        let result403: any = null;
        let resultData403  = _responseText;
        result403 = Types.initProblemDetails(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);

    } else if (status === 404) {
        const _responseText = response.data;
        let result404: any = null;
        let resultData404  = _responseText;
        result404 = Types.initProblemDetails(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.AccountResponse>(null as any);
}

/**
 * @return OK
 */
export function accountsDELETE(id: number, config?: AxiosRequestConfig | undefined): Promise<Types.AccountResponse> {
    let url_ = getBaseUrl() + "/api/accounts/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigAccountsDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
            ..._requestConfigAccountsDELETE?.headers,
            "Accept": "application/json",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processAccountsDELETE(_response);
    });
}

function processAccountsDELETE(response: AxiosResponse): Promise<Types.AccountResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.initAccountResponse(resultData200);
        return Promise.resolve<Types.AccountResponse>(result200);

    } else if (status === 400) {
        const _responseText = response.data;
        let result400: any = null;
        let resultData400  = _responseText;
        result400 = Types.initProblemDetails(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);

    } else if (status === 403) {
        const _responseText = response.data;
        let result403: any = null;
        let resultData403  = _responseText;
        result403 = Types.initProblemDetails(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);

    } else if (status === 404) {
        const _responseText = response.data;
        let result404: any = null;
        let resultData404  = _responseText;
        result404 = Types.initProblemDetails(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.AccountResponse>(null as any);
}

/**
 * @return OK
 */
export function deposit(id: number, body: Types.DepositRequest, config?: AxiosRequestConfig | undefined): Promise<Types.TransactionResponse> {
    let url_ = getBaseUrl() + "/api/accounts/{id}/deposit";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = Types.serializeDepositRequest(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigDeposit,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigDeposit?.headers,
            "Content-Type": "application/json",
            "Accept": "application/json",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processDeposit(_response);
    });
}

function processDeposit(response: AxiosResponse): Promise<Types.TransactionResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.initTransactionResponse(resultData200);
        return Promise.resolve<Types.TransactionResponse>(result200);

    } else if (status === 400) {
        const _responseText = response.data;
        let result400: any = null;
        let resultData400  = _responseText;
        result400 = Types.initProblemDetails(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);

    } else if (status === 403) {
        const _responseText = response.data;
        let result403: any = null;
        let resultData403  = _responseText;
        result403 = Types.initProblemDetails(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);

    } else if (status === 404) {
        const _responseText = response.data;
        let result404: any = null;
        let resultData404  = _responseText;
        result404 = Types.initProblemDetails(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.TransactionResponse>(null as any);
}

/**
 * @return OK
 */
export function withdraw(id: number, body: Types.WithdrawRequest, config?: AxiosRequestConfig | undefined): Promise<Types.TransactionResponse> {
    let url_ = getBaseUrl() + "/api/accounts/{id}/withdraw";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = Types.serializeWithdrawRequest(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigWithdraw,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigWithdraw?.headers,
            "Content-Type": "application/json",
            "Accept": "application/json",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processWithdraw(_response);
    });
}

function processWithdraw(response: AxiosResponse): Promise<Types.TransactionResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.initTransactionResponse(resultData200);
        return Promise.resolve<Types.TransactionResponse>(result200);

    } else if (status === 400) {
        const _responseText = response.data;
        let result400: any = null;
        let resultData400  = _responseText;
        result400 = Types.initProblemDetails(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);

    } else if (status === 403) {
        const _responseText = response.data;
        let result403: any = null;
        let resultData403  = _responseText;
        result403 = Types.initProblemDetails(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);

    } else if (status === 404) {
        const _responseText = response.data;
        let result404: any = null;
        let resultData404  = _responseText;
        result404 = Types.initProblemDetails(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.TransactionResponse>(null as any);
}

/**
 * @return OK
 */
export function transfer(id: number, body: Types.TransferRequest, config?: AxiosRequestConfig | undefined): Promise<Types.TransactionResponse> {
    let url_ = getBaseUrl() + "/api/accounts/{id}/transfer";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = Types.serializeTransferRequest(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigTransfer,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigTransfer?.headers,
            "Content-Type": "application/json",
            "Accept": "application/json",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processTransfer(_response);
    });
}

function processTransfer(response: AxiosResponse): Promise<Types.TransactionResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.initTransactionResponse(resultData200);
        return Promise.resolve<Types.TransactionResponse>(result200);

    } else if (status === 400) {
        const _responseText = response.data;
        let result400: any = null;
        let resultData400  = _responseText;
        result400 = Types.initProblemDetails(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);

    } else if (status === 403) {
        const _responseText = response.data;
        let result403: any = null;
        let resultData403  = _responseText;
        result403 = Types.initProblemDetails(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);

    } else if (status === 404) {
        const _responseText = response.data;
        let result404: any = null;
        let resultData404  = _responseText;
        result404 = Types.initProblemDetails(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.TransactionResponse>(null as any);
}

/**
 * @return OK
 */
export function debit(id: number, body: Types.DebitRequest, config?: AxiosRequestConfig | undefined): Promise<Types.TransactionResponse> {
    let url_ = getBaseUrl() + "/api/accounts/{id}/debit";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = Types.serializeDebitRequest(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigDebit,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigDebit?.headers,
            "Content-Type": "application/json",
            "Accept": "application/json",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processDebit(_response);
    });
}

function processDebit(response: AxiosResponse): Promise<Types.TransactionResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.initTransactionResponse(resultData200);
        return Promise.resolve<Types.TransactionResponse>(result200);

    } else if (status === 400) {
        const _responseText = response.data;
        let result400: any = null;
        let resultData400  = _responseText;
        result400 = Types.initProblemDetails(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);

    } else if (status === 404) {
        const _responseText = response.data;
        let result404: any = null;
        let resultData404  = _responseText;
        result404 = Types.initProblemDetails(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.TransactionResponse>(null as any);
}

/**
 * @param page (optional) 
 * @param pageSize (optional) 
 * @return OK
 */
export function transactions(id: number, page?: number | undefined, pageSize?: number | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.PagedResponseOfTransactionResponse> {
    let url_ = getBaseUrl() + "/api/accounts/{id}/transactions?";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    if (page === null)
        throw new Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
        url_ += "page=" + encodeURIComponent("" + page) + "&";
    if (pageSize === null)
        throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
        url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigTransactions,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigTransactions?.headers,
            "Accept": "application/json",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processTransactions(_response);
    });
}

function processTransactions(response: AxiosResponse): Promise<Types.PagedResponseOfTransactionResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.initPagedResponseOfTransactionResponse(resultData200);
        return Promise.resolve<Types.PagedResponseOfTransactionResponse>(result200);

    } else if (status === 403) {
        const _responseText = response.data;
        let result403: any = null;
        let resultData403  = _responseText;
        result403 = Types.initProblemDetails(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);

    } else if (status === 404) {
        const _responseText = response.data;
        let result404: any = null;
        let resultData404  = _responseText;
        result404 = Types.initProblemDetails(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.PagedResponseOfTransactionResponse>(null as any);
}
let _requestConfigAccountsPOST: Partial<AxiosRequestConfig> | null;
export function getAccountsPOSTRequestConfig() {
  return _requestConfigAccountsPOST;
}
export function setAccountsPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigAccountsPOST = value;
}
export function patchAccountsPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigAccountsPOST = patch(_requestConfigAccountsPOST ?? {});
}

let _requestConfigAccountsAll: Partial<AxiosRequestConfig> | null;
export function getAccountsAllRequestConfig() {
  return _requestConfigAccountsAll;
}
export function setAccountsAllRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigAccountsAll = value;
}
export function patchAccountsAllRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigAccountsAll = patch(_requestConfigAccountsAll ?? {});
}

let _requestConfigAccountsGET: Partial<AxiosRequestConfig> | null;
export function getAccountsGETRequestConfig() {
  return _requestConfigAccountsGET;
}
export function setAccountsGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigAccountsGET = value;
}
export function patchAccountsGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigAccountsGET = patch(_requestConfigAccountsGET ?? {});
}

let _requestConfigAccountsDELETE: Partial<AxiosRequestConfig> | null;
export function getAccountsDELETERequestConfig() {
  return _requestConfigAccountsDELETE;
}
export function setAccountsDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigAccountsDELETE = value;
}
export function patchAccountsDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigAccountsDELETE = patch(_requestConfigAccountsDELETE ?? {});
}

let _requestConfigDeposit: Partial<AxiosRequestConfig> | null;
export function getDepositRequestConfig() {
  return _requestConfigDeposit;
}
export function setDepositRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigDeposit = value;
}
export function patchDepositRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigDeposit = patch(_requestConfigDeposit ?? {});
}

let _requestConfigWithdraw: Partial<AxiosRequestConfig> | null;
export function getWithdrawRequestConfig() {
  return _requestConfigWithdraw;
}
export function setWithdrawRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigWithdraw = value;
}
export function patchWithdrawRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigWithdraw = patch(_requestConfigWithdraw ?? {});
}

let _requestConfigTransfer: Partial<AxiosRequestConfig> | null;
export function getTransferRequestConfig() {
  return _requestConfigTransfer;
}
export function setTransferRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigTransfer = value;
}
export function patchTransferRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigTransfer = patch(_requestConfigTransfer ?? {});
}

let _requestConfigDebit: Partial<AxiosRequestConfig> | null;
export function getDebitRequestConfig() {
  return _requestConfigDebit;
}
export function setDebitRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigDebit = value;
}
export function patchDebitRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigDebit = patch(_requestConfigDebit ?? {});
}

let _requestConfigTransactions: Partial<AxiosRequestConfig> | null;
export function getTransactionsRequestConfig() {
  return _requestConfigTransactions;
}
export function setTransactionsRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigTransactions = value;
}
export function patchTransactionsRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigTransactions = patch(_requestConfigTransactions ?? {});
}